//!
//! 作用域规则
//!
//! 作用域规则是变量的所有权、借用规则、生命周期 中最重要的一部分，
//! 它给编译器提供了明确的指示，告诉编译器变量什么时候是有效的，
//! 什么时候资源应该被释放，或者哪些变量应该被销毁。
//!

/// 在 `Rust` 中变量并不仅仅在栈中保存数据，还会在堆中申请内存并保存堆指针
/// 比如说 `Box<T>`，`Rust` 中引用并加强了 `RAII` (Resource Acquisition Is Initialization 这个概念起源于 C++) 的使用，
/// 所以每当一个对象的作用域消失了，则这个对象就会被销毁并且回收对应的资源。
///  
/// 这种行为可以有效的防止内存泄露的问题，而且你永远不需要手动的释放内存，
/// 并且也不需要担心内存泄露的问题。
fn raii() {
    fn create_box() {
        // 在堆中申请一块内存来存放数字
        let _box1 = Box::new(3i32);

        // 因为作用域已经结束，所以 `_box1` 在这里被销毁了并且堆上的内存也被回收了。
    }

    // 在堆上申请一块内存来存放数字
    let _box2 = Box::new(5i32);

    // 嵌套的作用域
    {
        // 在堆上申请一块内存来存放数字
        let _box3 = Box::new(4i32);

        // 因为作用域已经结束，所以 `_box3` 在这里被销毁了并且堆上的内存也被回收了。
    }

    // 在这里在堆上申请了很多内存，但是又因为作用域结束，马上就被回收了。
    for _ in 0u32..1_000 {
        create_box();
    }

    // 因为作用域已经结束，所以 `_box2` 在这里被销毁了并且堆上的内存也被回收了。
}

/// Rust 中通过 `Drop` 特性提供了析构函数的概念，
/// 析构函数在资源被回收的时候自动调用，用于清理执行一些清理的动作，
/// 这个特性并不要求所有的类型都要实现它，只有你自己定义的特殊类型需要一些特殊的逻辑的时候
/// 才会需要手动实现这个特性来实现一些特殊的清理操作。
///
/// 下面这个例子就是一个析构函数的实例
fn descructor() {
    struct ToDrop;

    impl Drop for ToDrop {
        fn drop(&mut self) {
            println!("ToDrop is being dropped");
        }
    }

    let x = ToDrop;
    println!("Made a ToDrop!");
}

fn main() {
    raii();
    descructor();
}
