//!
//! 泛型函数
//!
//! 泛型的相关规则也可以直接使用在函数上，当一个类型 `T` 被声明成了 `<T>`，则该类型就是泛型。
//!
//! 如果编译器不能推断出泛型的参数或者泛型的返回值的情况下，需要明确的指出泛型的类型。
//!

struct A; // 具体类型 `A`
struct S(A); // 具体类型 `S`
struct SGen<T>(T); // 泛型类型 `SGen`.

// 下面这些函数都会直接转移变量的所有权，一旦调用了函数，变量就被转移到函数中了，而函数中什么都没做
// 当函数结束的时候会直接回收掉所有传入的参数。

// `reg_fn` 函数接受一个具体的类型 `S`，所以该函数不是泛型的。
fn reg_fn(_s: S) {}

// `gen_spec_t` 函数接受一个 `SGen<A>`，虽然 `SGen` 是泛型，
// 但是我们手动指定了 `SGen` 的类型为 `A`，所以该函数也不是泛型的
fn gen_spec_t(_s: SGen<A>) {}

// 这里同上，因为手动指定了 `SGen` 的类型是 `i32` 所以该函数也不是泛型的。
fn gen_spec_i32(_s: SGen<i32>) {}

// `generic` 函数通过 <T> 声明了一个泛型 `T` 的类型，然后把这个泛型 `T`，传递给了 `SGen`，
// 所以该函数是一个拥有一个泛型类型的泛型函数。
fn generic<T>(_s: SGen<T>) {}

fn main() {
    // 使用非泛型的函数
    reg_fn(S(A)); // 具体类型
    gen_spec_t(SGen(A)); // 隐式指定 `SGen` 的泛型类型为 `A`。
    gen_spec_i32(SGen(6)); // 隐式指定 `SGen` 的泛型类型为 `i32`。

    // 手动明确指定函数的泛型类型为 `char` 类型
    generic::<char>(SGen('a'));

    // 隐式指定泛型类型为 `char` 类型
    generic(SGen('c'));
}
