//!
//! 文档测试的设计理念
//!
//! 文档测试主要是用于说明提供的能力以及使用方法，它是非常重要的指导方针之一，
//! 它允许使用完整的实例来说明提供的功能是什么。
//!

///
/// 文档测试
/// 主要的测试方式是通过源代码中使用 `///` 开头的代码注释中的代码块来进行测试，
/// 由于 `///` 开头的注释支持 `Markdown` 语法，所以在注释中出现的代码块会默认是
/// `Rust` 的测试代码，可以由 `Rust` 对代码块中的代码进行单元测试。
///
/// ```
/// let sum = testing::add(1, 2);
/// assert!(sum == 3);
/// ```
///
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}

///
/// 文档测试中还支持异常测试，这个例子里面包含了两个测试块，`示例`，`异常`
///
/// 下面的函数是两数相除
///
/// # 示例
///
/// ```
/// let result = testing::div(10, 2);
/// assert_eq!(result, 5);
/// ```
///
/// # 异常
///
/// 第二个数字为 `0` 的时候将产生异常
///
/// 这里使用了特殊的属性标记 `rust,should_panic`，其中 `rust` 是语言类型，`should_panic` 是告诉编译器这里的代码应该产生异常。
///
/// ```rust,should_panic
/// let result = testing::div(10, 0); // 这个函数会产生异常。
/// ```
///
pub fn div(a: i32, b: i32) -> i32 {
    if b == 0 {
        panic!("Divide-by-zero error");
    }

    a / b
}

///
/// 有些时候写的测试代码可能会需要包含 `?` 操作符来快捷展开 `Result` 的结果，
/// 这时候会文档测试会失败，因为默认的测试代码返回值应该是 `()`，针对这个情况
/// 提供了一个隐式的包装代码能力。
///
/// ```
/// # // 使用特殊标记 `#` 来让一些代码不显示在最终的文档中，但是这些代码依旧会参与实际的测试编译中。
/// # fn try_main() -> Result<(), String> { // 这个代码是有效的包装代码，不会显示在文档中，但是会参与测试的编译
/// let res = testing::try_div(10, 2)?; // 只有这行代码会展示在最终的文档中
/// # Ok(()) // 这里返回一个 `()`
/// # }
/// # fn main() { // 测试代码的主入口和正常 `main` 函数是一样的
/// #    try_main().unwrap(); // 调用 `try_main` 方法来执行测试逻辑
/// #                         // 如果测试有问题的话 这里应该会 `panic!`
/// # }
/// ```
pub fn try_div(a: i32, b: i32) -> Result<i32, String> {
    if b == 0 {
        Err(String::from("Divide-by-zero"))
    } else {
        Ok(a / b)
    }
}
