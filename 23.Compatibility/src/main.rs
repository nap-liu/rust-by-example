//!
//! Rust 语言在非常快速的发展，因此可能会出现某些兼容性问题，尽管
//! 已经在尽可能的保证向前兼容，但是依旧有些特性会出现改变。
//!

///
/// Rust 和许多其他的编程语言一样也拥有关键字的概念，这些关键字都对 Rust 有特定的功能，
/// 所以你不能使用这些关键字来定义变量或者函数或者其他的一些东西，原始标记（Raw identifiers）
/// 符号可以让你使用任意的文字包括关键字来定义一些变量或者函数或者任意其他的东西。
///
/// 这个特性在 Rust 引入新的关键字的时候会非常有用，有些文字在现在的版本不是关键字，
/// 但是后面的发展过程中把这个文字纳入了关键字的范围就会导致原来的一些库没有办法使用了，
/// 因为这些库使用了新的关键字当做变量或者函数等等的一些对象上。
///
/// 举个例子，我们有一个包(crate) 叫 `foo` 是使用 2015 版本的 Rust 编译的，该包导出了一个方法
/// 叫 `try`。这个 `try` 被 2018 版本的 Rust 中列为了关键字，如果没有原始标记的话，我们
/// 没有任何办法去使用这个函数。
///
/// ```
/// extern crate foo;
///
/// fn main () {
///     foo::try(); // 这里会报错 因为 `try` 在 2018 版本以后是关键字
///     // 通过原始标记 `r#` 开头来标记后面的文字是原始字符，这里实际上还是调用的 `foo:try` 方法，这里的 `r#` 只是告诉编译器我要使用关键字了。
///     foo::r#try(); // 这里可以正常编译不会报错
/// }
///
/// ```
///
/// ```shell
/// error: expected identifier, found keyword `try`
///  --> src/main.rs:4:4
///  |
///4 | foo::try();
///  |      ^^^ expected identifier, found keyword
/// ```
///

fn main() {
    println!("Hello, world!");
}
