//!
//! Rust 没有为基础类型提供隐式的类型强制转换
//! 但是可以使用 `as` 关键字对基础类型进行明确的强制类型转换
//!
//! 数字类型的强制转换规则遵循C的转换规则，除非某些在C中未定义的行为，
//! Rust 明确的规定了所有整数之间的转换规则。
//!
// Suppress all warnings from casts which overflow.
#![allow(overflowing_literals)]

fn main() {
    let decimal = 65.4321_f32;

    // 错误! 没有从浮点数到整数的隐式转换规则。
    let integer: u8 = decimal;
    // FIXME ^ 注释这行代码

    // 手动明确指定转换规则
    let integer = decimal as u8; // f32 强制转换到 u8
    let character = integer as char; // u8 强制转换到 char

    // 错误! 有几个转换限制，f32 不能直接转换为 char
    let character = decimal as char;
    // FIXME ^ 注释这行代码

    println!("Casting: {} -> {} -> {}", decimal, integer, character);

    // 当任意类型转换到无符号类型的时候，源类型的数据会被加或减到目标类型的最大容量值，
    // 直到数据能够存放到目标类型内为止

    // 如果数字能直接被目标类型存放则直接转换
    println!("1000 as a u16 is: {}", 1000 as u16);

    // 底层会保留前八个比特位 (LSB)
    // 剩余的其他位 (MSB) 会被截断
    // 1000 - 256 - 256 - 256 = 232
    println!("1000 as a u8 is : {}", 1000 as u8);
    // -1 + 256 = 255
    println!("  -1 as a u8 is : {}", (-1i8) as u8);

    // 正整数的情况下和取模的计算相同
    println!("1000 mod 256 is : {}", 1000 % 256);

    // 转换为有符号整数的时候，除了源数据的第一位以外，其他的位会自动转到对应目标位上
    // 如果原始数据的最高位为1的话，转换的结果就是负数

    // 目标类型能放下直接转换
    println!(" 128 as a i16 is: {}", 128 as i16);

    // 如果原始值正好是目标的正负边界值，则会直接使用这个值
    // 128 的二进制是 0b1000_0000 因为负整数的二进制表示形式就是
    // 最高位比特位为 1 表示为负数 剩余的位数以补码形式展示
    // 所以这里的结果就是 -128
    println!(" 128 as a i8 is : {}", 128 as i8);

    // 重复上面的例子 有符号转无符号
    // 1000 as u8 -> 232
    println!("1000 as a u8 is : {}", 1000 as u8);
    // 232的二进制是 0b1110_1000 直接可以放到 i8 的类型中
    // 计算过程 0b1000_0000 - 0b110_1000 = 24
    // 因为最高位是 1 所以剩余的位按照补码形式显示 最终的结果是 -24
    println!(" 232 as a i8 is : {}", 232 as i8);

    // 从 Rust 1.45 以后 `as` 关键字在转换`浮点数`到`整数`的时候表现为 *饱和转换*
    // 如果浮点数超过了目标类型的最大边界，则转换为目标的最大边界，
    // 如果浮点数小于目标类型的最小边界，则转换为目标的最小边界。

    // 300.0 转换为 u8 是 255
    println!(" 300.0 as u8 is : {}", 300.0_f32 as u8);
    // -100.0 转换为 u8 是 0
    println!("-100.0 as u8 is : {}", -100.0_f32 as u8);
    // nan 转换为 u8 是 0
    println!("   nan as u8 is : {}", f32::NAN as u8);

    // 上面这些转换会有一些运行时的性能损失，可以通过使用不安全的方法来避免，
    // 但是这些方法可能会溢出并返回不安全的值，应该小心使用这些方法。
    unsafe {
        // 300.0 转换为 u8 是 44
        println!(" 300.0 as u8 is : {}", 300.0_f32.to_int_unchecked::<u8>());
        // -100.0 转换为 u8 是 156
        println!(
            "-100.0 as u8 is : {}",
            (-100.0_f32).to_int_unchecked::<u8>()
        );
        // nan 转换为 u8 是 0
        println!("   nan as u8 is : {}", f32::NAN.to_int_unchecked::<u8>());
    }
}
